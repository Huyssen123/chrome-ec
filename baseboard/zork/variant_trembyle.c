/* Copyright 2020 The Chromium OS Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

#include "common.h"
#include "console.h"
#include "driver/retimer/ps8811.h"
#include "fan.h"
#include "fan_chip.h"
#include "gpio.h"
#include "hooks.h"
#include "i2c.h"
#include "ioexpander.h"
#include "timer.h"

#define CPRINTSUSB(format, args...) cprints(CC_USBCHARGE, format, ## args)
#define CPRINTFUSB(format, args...) cprintf(CC_USBCHARGE, format, ## args)

/*****************************************************************************
 * Fan
 */

/* Physical fans. These are logically separate from pwm_channels. */
const struct fan_conf fan_conf_0 = {
	.flags = FAN_USE_RPM_MODE,
	.ch = MFT_CH_0,	/* Use MFT id to control fan */
	.pgood_gpio = -1,
	.enable_gpio = -1,
};
const struct fan_rpm fan_rpm_0 = {
	.rpm_min = 3100,
	.rpm_start = 3100,
	.rpm_max = 6900,
};
const struct fan_t fans[] = {
	[FAN_CH_0] = {
		.conf = &fan_conf_0,
		.rpm = &fan_rpm_0,
	},
};
BUILD_ASSERT(ARRAY_SIZE(fans) == FAN_CH_COUNT);

const static struct ec_thermal_config thermal_thermistor = {
	.temp_host = {
		[EC_TEMP_THRESH_HIGH] = C_TO_K(75),
		[EC_TEMP_THRESH_HALT] = C_TO_K(80),
	},
	.temp_host_release = {
		[EC_TEMP_THRESH_HIGH] = C_TO_K(65),
	},
	.temp_fan_off = C_TO_K(25),
	.temp_fan_max = C_TO_K(50),
};

const static struct ec_thermal_config thermal_cpu = {
	.temp_host = {
		[EC_TEMP_THRESH_HIGH] = C_TO_K(85),
		[EC_TEMP_THRESH_HALT] = C_TO_K(95),
	},
	.temp_host_release = {
		[EC_TEMP_THRESH_HIGH] = C_TO_K(65),
	},
	.temp_fan_off = C_TO_K(25),
	.temp_fan_max = C_TO_K(50),
};

struct ec_thermal_config thermal_params[TEMP_SENSOR_COUNT];

static void setup_fans(void)
{
	thermal_params[TEMP_SENSOR_CHARGER] = thermal_thermistor;
	thermal_params[TEMP_SENSOR_SOC] = thermal_thermistor;
	thermal_params[TEMP_SENSOR_CPU] = thermal_cpu;
}
DECLARE_HOOK(HOOK_INIT, setup_fans, HOOK_PRIO_DEFAULT);

/*****************************************************************************
 * USB-A Retimer tuning
 */
#define PS8811_ACCESS_RETRIES 2

/* PS8811 gain tuning */
static void ps8811_tuning_init(void)
{
	int rv;
	int retry;

	/* Turn on the retimers */
	ioex_set_level(IOEX_USB_A0_RETIMER_EN, 1);
	ioex_set_level(IOEX_USB_A1_RETIMER_EN, 1);

	/* USB-A0 can run with default settings */
	for (retry = 0; retry < PS8811_ACCESS_RETRIES; ++retry) {
		int val;

		rv = i2c_read8(I2C_PORT_USBA0,
				PS8811_I2C_ADDR_FLAGS + PS8811_REG_PAGE1,
				PS8811_REG1_USB_BEQ_LEVEL, &val);
		if (!rv)
			break;
	}
	if (rv) {
		ioex_set_level(IOEX_USB_A0_RETIMER_EN, 0);
		CPRINTSUSB("C0: PS8811 not detected");
	}

	/* USB-A1 needs to increase gain to get over MB/DB connector */
	for (retry = 0; retry < PS8811_ACCESS_RETRIES; ++retry) {
		rv = i2c_write8(I2C_PORT_USBA1,
				PS8811_I2C_ADDR_FLAGS + PS8811_REG_PAGE1,
				PS8811_REG1_USB_BEQ_LEVEL,
				PS8811_BEQ_I2C_LEVEL_UP_13DB |
				PS8811_BEQ_PIN_LEVEL_UP_18DB);
		if (!rv)
			break;
	}
	if (rv) {
		ioex_set_level(IOEX_USB_A1_RETIMER_EN, 0);
		CPRINTSUSB("C1: PS8811 not detected");
	}
}
DECLARE_HOOK(HOOK_CHIPSET_STARTUP, ps8811_tuning_init, HOOK_PRIO_DEFAULT);

static void ps8811_retimer_off(void)
{
	/* Turn on the retimers */
	ioex_set_level(IOEX_USB_A0_RETIMER_EN, 0);
	ioex_set_level(IOEX_USB_A1_RETIMER_EN, 0);
}
DECLARE_HOOK(HOOK_CHIPSET_SHUTDOWN, ps8811_retimer_off, HOOK_PRIO_DEFAULT);

/*****************************************************************************
 * MST hub
 */

static void mst_hpd_handler(void)
{
	int hpd = 0;

	/* Pass HPD through from DB OPT3 MST hub to AP's DP1. */
	ioex_get_level(IOEX_MST_HPD_OUT, &hpd);
	gpio_set_level(GPIO_DP1_HPD, hpd);
	ccprints("MST HPD %d", hpd);
}
DECLARE_DEFERRED(mst_hpd_handler);

void mst_hpd_interrupt(enum ioex_signal signal)
{
	/* Debounce for 2 msec. */
	hook_call_deferred(&mst_hpd_handler_data, (2 * MSEC));
}
